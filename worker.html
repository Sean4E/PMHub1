<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>PM Hub Worker</title>
    <link rel="stylesheet" href="pm-hub-styles.css">

    <!-- QR Scanner Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qr-scanner/1.4.2/qr-scanner.umd.min.js"></script>

    <!-- Google Drive API -->
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>

    <!-- Firebase -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, doc, setDoc, getDoc, onSnapshot } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        // Initialize Firebase (MUST match hub's config exactly)
        const firebaseConfig = {
            apiKey: "AIzaSyDnwDzHtjFKaWY-VwIMJtomfunkp7t9GFc",
            authDomain: "assettracker1-5b976.firebaseapp.com",
            projectId: "assettracker1-5b976",
            storageBucket: "assettracker1-5b976.firebasestorage.app",
            messagingSenderId: "260186083597",
            appId: "1:260186083597:web:5ec0eb9d5f8a4132022044"
        };

        try {
            const app = initializeApp(firebaseConfig);
            const db = getFirestore(app);

            window.firebaseEnabled = true;
            window.db = db;
            window.firestore = { collection, doc, setDoc, getDoc, onSnapshot };
            console.log('‚úì Worker: Firebase initialized');
        } catch (error) {
            console.error('Worker: Firebase init error:', error);
            window.firebaseEnabled = false;
        }
    </script>

    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--bg-dark);
            overflow-x: hidden;
            font-family: system-ui, -apple-system, sans-serif;
            color: var(--text-primary);
        }

        /* Header */
        .worker-header {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--glass-border);
            padding: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .worker-name {
            font-size: 18px;
            font-weight: 600;
        }

        /* Sync Status Indicators */
        .sync-status {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 12px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-tertiary);
        }

        .status-dot.synced {
            background: var(--accent-success);
            animation: pulse 2s infinite;
        }

        .status-dot.syncing {
            background: var(--accent-warning);
            animation: blink 1s infinite;
        }

        .status-dot.offline {
            background: var(--accent-danger);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes blink {
            0%, 50%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.3; }
        }

        .pending-badge {
            background: var(--accent-warning);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            min-width: 20px;
            text-align: center;
        }

        .logout-btn {
            padding: 8px 16px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--accent-danger);
            border-radius: 8px;
            color: var(--accent-danger);
            font-size: 14px;
            cursor: pointer;
        }

        /* Clock Out Button - Always visible when clocked in */
        .clock-out-fixed {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 999;
            padding: 16px 24px;
            background: linear-gradient(135deg, var(--accent-danger), #dc2626);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 18px;
            font-weight: 600;
            box-shadow: 0 8px 20px rgba(239, 68, 68, 0.4);
            cursor: pointer;
            display: none;
        }

        .clock-out-fixed:active {
            transform: scale(0.95);
        }

        /* Container */
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Big Action Buttons */
        .big-btn {
            width: 100%;
            padding: 24px;
            font-size: 20px;
            font-weight: 600;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            margin: 12px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            transition: all 0.2s;
        }

        .big-btn:active {
            transform: scale(0.98);
        }

        .big-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .big-btn.success {
            background: linear-gradient(135deg, var(--accent-success), #059669);
            color: white;
        }

        .big-btn.primary {
            background: linear-gradient(135deg, var(--accent-primary), #2563eb);
            color: white;
        }

        .big-btn.danger {
            background: linear-gradient(135deg, var(--accent-danger), #dc2626);
            color: white;
        }

        .big-btn.warning {
            background: linear-gradient(135deg, var(--accent-warning), #d97706);
            color: white;
        }

        /* Forms */
        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 14px;
        }

        select, input, textarea {
            width: 100%;
            padding: 14px;
            background: rgba(21, 25, 50, 0.9);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            color: #ffffff;
            font-size: 16px;
        }

        select option {
            background: #1a1f3a;
            color: #ffffff;
            padding: 12px;
        }

        /* Task Cards */
        .task-card {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .task-card.active {
            border-color: var(--accent-primary);
            background: rgba(59, 130, 246, 0.1);
        }

        .task-name {
            font-weight: 600;
            margin-bottom: 8px;
        }

        .task-meta {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        .task-actions {
            display: flex;
            gap: 8px;
        }

        .btn-sm {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }

        .btn-start {
            background: var(--accent-primary);
            color: white;
        }

        .btn-complete {
            background: var(--accent-success);
            color: white;
        }

        .section-header {
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin: 24px 0 12px 0;
            letter-spacing: 0.5px;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-tertiary);
        }

        .empty-icon {
            font-size: 48px;
            margin-bottom: 12px;
        }

        .hidden {
            display: none;
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            top: 80px;
            right: 20px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 16px 20px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 300px;
            animation: slideIn 0.3s ease;
        }

        .toast.success {
            border-color: var(--accent-success);
            background: rgba(16, 185, 129, 0.1);
        }

        .toast.info {
            border-color: var(--accent-primary);
            background: rgba(59, 130, 246, 0.1);
        }

        .toast.warning {
            border-color: var(--accent-warning);
            background: rgba(245, 158, 11, 0.1);
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Status Display */
        .status-card {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
        }

        .status-card.clocked-in {
            border-color: var(--accent-success);
            background: rgba(16, 185, 129, 0.1);
        }

        .current-task-display {
            background: rgba(59, 130, 246, 0.1);
            border: 2px solid var(--accent-primary);
            border-radius: 12px;
            padding: 16px;
            margin: 12px 0;
        }

        .current-task-title {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .current-task-name {
            font-size: 18px;
            font-weight: 700;
        }

        /* Notification Bell & Badge */
        .notification-bell {
            position: relative;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
            margin-right: 12px;
        }

        .notification-bell:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .notification-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            background: var(--accent-danger);
            color: white;
            font-size: 10px;
            font-weight: 600;
            min-width: 18px;
            height: 18px;
            border-radius: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
            animation: badge-pulse 2s infinite;
        }

        .notification-badge.hidden {
            display: none;
        }

        @keyframes badge-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Notification Center Panel */
        .notification-center {
            position: fixed;
            top: 80px;
            right: -400px;
            width: 380px;
            max-height: calc(100vh - 100px);
            background: var(--bg-dark);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 999;
            transition: right 0.3s ease;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .notification-center.active {
            right: 20px;
        }

        .notif-center-header {
            padding: 20px;
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .notif-center-title {
            font-size: 18px;
            font-weight: 600;
        }

        .notif-mark-read {
            background: none;
            border: none;
            color: var(--accent-primary);
            font-size: 12px;
            cursor: pointer;
            padding: 4px 8px;
        }

        .notif-center-body {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .notif-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 14px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .notif-item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .notif-item.unread {
            border-left: 3px solid var(--accent-primary);
            background: rgba(59, 130, 246, 0.05);
        }

        .notif-item-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .notif-item-icon {
            font-size: 16px;
        }

        .notif-item-user {
            font-weight: 600;
            font-size: 13px;
            flex: 1;
        }

        .notif-item-time {
            font-size: 11px;
            color: var(--text-tertiary);
        }

        .notif-item-message {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .notif-item-action {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        .notif-action-link {
            color: var(--accent-primary);
            font-size: 12px;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .notif-action-link:hover {
            text-decoration: underline;
        }

        @media (max-width: 600px) {
            .notification-center {
                right: -100%;
                width: calc(100% - 40px);
                max-width: 380px;
            }

            .notification-center.active {
                right: 20px;
            }
        }

        /* Task Chat Styles */
        .chat-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: var(--accent-danger);
            color: white;
            font-size: 11px;
            font-weight: 600;
            min-width: 20px;
            height: 20px;
            border-radius: 10px;
            padding: 0 6px;
            margin-left: 8px;
        }

        .chat-badge.hidden {
            display: none;
        }

        .chat-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            overflow-y: auto;
        }

        .chat-modal.active {
            display: block;
        }

        .chat-container {
            max-width: 600px;
            margin: 20px auto;
            background: var(--bg-dark);
            border-radius: 16px;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 40px);
            max-height: 700px;
        }

        .chat-header {
            padding: 20px;
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-title {
            font-size: 18px;
            font-weight: 600;
        }

        .chat-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .chat-close {
            background: none;
            border: none;
            color: white;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .chat-message {
            display: flex;
            flex-direction: column;
            max-width: 80%;
        }

        .chat-message.own {
            align-self: flex-end;
        }

        .chat-message.other {
            align-self: flex-start;
        }

        .chat-message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .chat-message.own .chat-message-header {
            justify-content: flex-end;
        }

        .chat-message-user {
            font-weight: 600;
            color: var(--accent-primary);
        }

        .chat-message.own .chat-message-user {
            color: var(--accent-success);
        }

        .chat-message-time {
            color: var(--text-tertiary);
        }

        .chat-message-bubble {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 12px 16px;
            word-wrap: break-word;
        }

        .chat-message.own .chat-message-bubble {
            background: rgba(16, 185, 129, 0.1);
            border-color: var(--accent-success);
        }

        .chat-input-container {
            padding: 16px 20px;
            border-top: 1px solid var(--glass-border);
            display: flex;
            gap: 12px;
        }

        .chat-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 12px 16px;
            color: white;
            font-size: 14px;
            font-family: inherit;
            resize: none;
            max-height: 100px;
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .chat-send-btn {
            background: var(--accent-primary);
            border: none;
            color: white;
            border-radius: 12px;
            padding: 12px 24px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .chat-send-btn:hover {
            background: #2563eb;
        }

        .chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .chat-empty {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .chat-empty-icon {
            font-size: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="worker-header">
        <div class="worker-name" id="worker-name">Loading...</div>
        <div class="sync-status">
            <button class="notification-bell" onclick="toggleNotificationCenter()" id="notification-bell">
                üîî
                <span class="notification-badge" id="notification-badge">0</span>
            </button>
            <div class="status-indicator" id="sync-indicator">
                <div class="status-dot" id="sync-dot"></div>
                <span id="sync-text">Syncing...</span>
            </div>
            <div class="status-indicator" id="upload-indicator" style="display: none;">
                <span>üì§</span>
                <span class="pending-badge" id="pending-count">0</span>
            </div>
        </div>
        <button class="logout-btn" onclick="logout()">Logout</button>
    </div>

    <!-- Clock Out Button (fixed, always visible when clocked in) -->
    <button class="clock-out-fixed" id="clock-out-fixed-btn" onclick="requestClockOut()">
        üèÅ Clock Out
    </button>

    <!-- Notification Center Panel -->
    <div class="notification-center" id="notification-center">
        <div class="notif-center-header">
            <div class="notif-center-title">Notifications</div>
            <button class="notif-mark-read" onclick="markAllAsRead()">Mark all read</button>
        </div>
        <div class="notif-center-body" id="notif-center-body">
            <div class="empty-state">
                <div style="font-size: 48px; margin-bottom: 12px;">üîî</div>
                <div>No notifications</div>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Step 1: Clock In (initial screen) -->
        <div id="clock-in-screen">
            <div class="status-card">
                <div style="font-size: 56px; font-weight: 300; font-variant-numeric: tabular-nums; margin-bottom: 8px;" id="live-clock">00:00:00</div>
                <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 16px;" id="live-date">Loading...</div>
                <div style="font-size: 20px; font-weight: 600; margin-bottom: 8px;">Ready to Start</div>
                <div style="color: var(--text-secondary);">Select a project to clock in</div>
            </div>

            <div class="form-group">
                <label class="form-label">Select Project</label>
                <select id="project-select" onchange="enableClockIn()">
                    <option value="">-- Choose Project --</option>
                </select>
            </div>

            <button class="big-btn success" id="clock-in-btn" onclick="clockIn()" disabled>
                ‚è∞ Clock In to Project
            </button>
        </div>

        <!-- Step 2: Task Selection (after clock in) -->
        <div id="task-selection-screen" class="hidden">
            <div class="status-card clocked-in">
                <div style="font-size: 16px; font-weight: 600; margin-bottom: 4px;">Clocked In</div>
                <div id="clocked-project-name" style="color: var(--text-secondary);"></div>
            </div>

            <div class="section-header">Choose Area & Task to Start</div>

            <div class="form-group">
                <label class="form-label">Area</label>
                <select id="area-select" onchange="loadTasksForArea()">
                    <option value="">-- Select Area --</option>
                </select>
            </div>

            <div class="form-group" id="task-select-group" class="hidden">
                <label class="form-label">Task</label>
                <select id="task-select-dropdown">
                    <option value="">-- Select Task --</option>
                </select>
            </div>

            <button class="big-btn primary" id="start-task-btn" onclick="startSelectedTask()" disabled>
                ‚ñ∂Ô∏è Start Task
            </button>
        </div>

        <!-- Step 3: Active Task (working on task) -->
        <div id="active-task-screen" class="hidden">
            <div class="current-task-display">
                <div class="current-task-title">Currently Working On</div>
                <div class="current-task-name" id="current-task-name"></div>
                <div style="font-size: 13px; color: var(--text-secondary); margin-top: 4px;" id="current-task-area"></div>
            </div>

            <!-- Task Actions -->
            <button class="big-btn primary" onclick="openTaskChat()">
                üí¨ Task Chat <span id="task-chat-badge" class="chat-badge hidden">0</span>
            </button>

            <button class="big-btn warning" onclick="showReportModal()">
                üì∏ Send Report
            </button>

            <button class="big-btn primary" onclick="showToolScanner()">
                üì± Scan Tool QR Code
            </button>

            <button class="big-btn success" onclick="completeCurrentTask()">
                ‚úÖ Complete Task
            </button>

            <div style="margin-top: 20px; padding: 12px; background: rgba(239, 68, 68, 0.1); border: 1px solid var(--accent-danger); border-radius: 8px; font-size: 14px; text-align: center;">
                <strong>Remember:</strong> Clock out when done for the day
            </div>
        </div>
    </div>

    <!-- Report Modal with Camera -->
    <div id="report-modal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 1000; overflow-y: auto;">
        <div style="max-width: 700px; margin: 20px auto; background: var(--bg-dark); border-radius: 16px; padding: 24px; border: 1px solid var(--glass-border);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h3 style="font-size: 20px;">üì∏ Send Report</h3>
                <button onclick="closeReportModal()" style="background: none; border: none; color: white; font-size: 28px; cursor: pointer; line-height: 1;">√ó</button>
            </div>

            <!-- Camera Controls (Always Visible) -->
            <div style="background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                <div style="font-size: 14px; font-weight: 600; margin-bottom: 12px; color: var(--text-secondary);">CAPTURE MEDIA</div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button class="btn-sm btn-start" id="start-camera-btn" onclick="startCamera()">üì∑ Open Camera</button>
                    <button class="btn-sm" id="switch-camera-btn" onclick="switchCamera()" style="display: none; background: var(--accent-primary); color: white;">üîÑ Switch</button>
                    <button class="btn-sm btn-start" id="take-photo-btn" onclick="takePhoto()" style="display: none;">üì∏ Take Photo</button>
                    <button class="btn-sm btn-danger" id="start-record-btn" onclick="startRecording()" style="display: none; background: var(--accent-danger); color: white;">üé• Record Video</button>
                    <button class="btn-sm btn-danger" id="stop-record-btn" onclick="stopRecording()" style="display: none; background: var(--accent-danger); color: white;">‚èπÔ∏è Stop Recording</button>
                    <button class="btn-sm" id="close-camera-btn" onclick="closeCamera()" style="display: none; background: var(--glass-bg); border: 1px solid var(--glass-border); color: white;">‚úï Close Camera</button>
                </div>

                <!-- Video Preview -->
                <div id="camera-preview-container" style="display: none; margin-top: 16px;">
                    <video id="camera-preview" autoplay playsinline muted style="width: 100%; max-height: 350px; border-radius: 12px; background: #000;"></video>
                    <canvas id="photo-canvas" style="display: none;"></canvas>
                </div>
            </div>

            <!-- Captured Media Gallery -->
            <div id="media-gallery-container" style="background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: 12px; padding: 16px; margin-bottom: 20px; display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <div style="font-size: 14px; font-weight: 600; color: var(--text-secondary);">ATTACHED MEDIA</div>
                    <div style="font-size: 12px; color: var(--text-tertiary);" id="media-count">0 files</div>
                </div>
                <div id="media-gallery" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 12px;"></div>
            </div>

            <!-- Text Report -->
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600; font-size: 14px; color: var(--text-secondary);">REPORT NOTES</label>
                <textarea id="report-text" placeholder="Describe the work completed, any issues, or updates..." rows="6" style="width: 100%; padding: 14px; background: rgba(21, 25, 50, 0.9); border: 1px solid var(--glass-border); border-radius: 12px; color: #ffffff; font-size: 14px; font-family: inherit; resize: vertical;"></textarea>
            </div>

            <!-- Submit -->
            <div style="display: flex; gap: 12px;">
                <button class="big-btn primary" onclick="submitReport()" style="flex: 1;">üì§ Submit Report</button>
                <button class="big-btn" onclick="closeReportModal()" style="flex: 1; background: var(--glass-bg); border: 1px solid var(--glass-border);">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Task Chat Modal -->
    <div id="task-chat-modal" class="chat-modal">
        <div class="chat-container">
            <div class="chat-header">
                <div>
                    <div class="chat-title" id="chat-task-name">Task Chat</div>
                    <div class="chat-subtitle" id="chat-task-info"></div>
                </div>
                <button class="chat-close" onclick="closeTaskChat()">√ó</button>
            </div>

            <div class="chat-messages" id="chat-messages">
                <div class="chat-empty">
                    <div class="chat-empty-icon">üí¨</div>
                    <div>No messages yet</div>
                    <div style="font-size: 13px; margin-top: 8px;">Start a conversation about this task</div>
                </div>
            </div>

            <div class="chat-input-container">
                <textarea
                    class="chat-input"
                    id="chat-input"
                    placeholder="Type your message..."
                    rows="1"
                    onkeydown="handleChatKeydown(event)"></textarea>
                <button class="chat-send-btn" onclick="sendChatMessage()">‚û§</button>
            </div>
        </div>
    </div>

    <!-- Tool QR Scanner Modal -->
    <div id="tool-scanner-modal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 1000;">
        <div style="max-width: 600px; margin: 20px auto; background: var(--bg-dark); border-radius: 16px; padding: 24px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h3>Scan Tool QR Code</h3>
                <button onclick="closeToolScanner()" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer;">√ó</button>
            </div>

            <!-- Scanner Controls -->
            <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                <button class="big-btn success" id="start-scanner-btn" onclick="startToolScanner()">üì± Start Scanner</button>
                <button class="big-btn danger" id="stop-scanner-btn" onclick="stopToolScanner()" style="display: none;">‚èπÔ∏è Stop Scanner</button>
            </div>

            <!-- Video for QR Scanner -->
            <div id="scanner-container" style="display: none; margin-bottom: 16px;">
                <video id="qr-video" style="width: 100%; max-height: 400px; border-radius: 12px; background: #000;"></video>
            </div>

            <div id="scanner-status" style="padding: 12px; background: rgba(59, 130, 246, 0.1); border: 1px solid var(--accent-primary); border-radius: 8px; text-align: center;">
                Ready to scan QR code
            </div>

            <!-- Tool Action (shown after scan) -->
            <div id="tool-action-container" style="display: none; margin-top: 16px;">
                <div style="padding: 16px; background: var(--glass-bg); border-radius: 12px; margin-bottom: 12px;">
                    <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;" id="scanned-tool-name"></div>
                    <div style="color: var(--text-secondary); font-size: 14px;" id="scanned-tool-info"></div>
                </div>
                <div style="display: flex; gap: 12px;">
                    <button class="big-btn success" id="checkout-btn" onclick="checkoutScannedTool()" style="flex: 1; display: none;">Check Out</button>
                    <button class="big-btn warning" id="checkin-btn" onclick="checkinScannedTool()" style="flex: 1; display: none;">Check In</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== GOOGLE DRIVE & APIS CONFIGURATION =====
        const CLIENT_ID = '904576712649-mcrh6cl8ei84gktkfg2f36eqc8454k1q.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyBoEAEz1NnCJDQ221u4XxXZIBaQrN-nlAc';
        const SCOPES = 'https://www.googleapis.com/auth/drive.file';

        let gapiInited = false;
        let gisInited = false;
        let tokenClient;
        let accessToken = null;

        // Global State
        let currentUser = null;
        let hubState = null;
        let selectedProject = null;
        let currentTask = null;
        let clockedInTime = null;

        // Camera & Media State
        let cameraStream = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let isFrontCamera = false;
        let capturedMedia = []; // Array to store multiple media files: [{blob, filename, type, preview}]

        // QR Scanner State
        let qrScanner = null;
        let scannedToolId = null;

        // Chat Polling State
        let chatPollInterval = null;
        let lastMessageCount = 0;

        // Helper function to check if task is assigned to current user
        function isTaskAssignedToMe(task) {
            if (!currentUser) return false;

            // Check new multi-assignee format
            if (task.assignees && Array.isArray(task.assignees)) {
                return task.assignees.some(assignee =>
                    assignee == currentUser.id || assignee == currentUser.name
                );
            }

            // Check old single assignee format (backward compatibility)
            if (task.assignee) {
                // Handle comma-separated assignees (from hub display format)
                if (typeof task.assignee === 'string' && task.assignee.includes(',')) {
                    const assignees = task.assignee.split(',').map(a => a.trim());
                    return assignees.some(assignee =>
                        assignee == currentUser.id || assignee == currentUser.name
                    );
                }
                return task.assignee == currentUser.id || task.assignee == currentUser.name;
            }

            return false;
        }

        // BroadcastChannel for instant state sync with hub
        const stateChannel = new BroadcastChannel('pm_hub_state');

        // Listen for state updates from hub
        stateChannel.onmessage = function(event) {
            if (event.data.type === 'STATE_UPDATED') {
                console.log('üì° Worker: State update received from hub');

                // Show syncing indicator
                updateSyncStatus('syncing');

                loadHubState();

                // Update indicators
                setTimeout(() => {
                    updateSyncStatus('synced');
                    updatePendingUploads();
                }, 500);

                // Check for new tasks assigned to me
                checkForNewTasks();

                // If currently on task selection, reload the project data
                if (selectedProject) {
                    const updatedProject = hubState.projects?.find(p => p.id == selectedProject.id);
                    if (updatedProject) {
                        selectedProject = updatedProject;
                        console.log('‚úì Worker: Updated selected project with latest data');

                        // If on task selection screen, refresh the task list
                        const taskScreen = document.getElementById('task-selection-screen');
                        if (taskScreen && !taskScreen.classList.contains('hidden')) {
                            console.log('üîÑ Refreshing task selection screen...');
                            const currentAreaId = document.getElementById('area-select')?.value;
                            if (currentAreaId) {
                                loadTasksForArea(); // Refresh task dropdown with new/updated tasks
                            }
                        }
                    }
                }

                // If currently working on a task with chat open, refresh chat (BroadcastChannel sync)
                if (currentTask) {
                    const project = hubState.projects?.find(p => p.id == currentTask.projectId);
                    if (project) {
                        const area = project.areas?.find(a => a.id == currentTask.areaId);
                        if (area) {
                            const task = area.tasks?.find(t => t.wbs == currentTask.wbs);
                            if (task) {
                                currentTask = task;

                                const chatModal = document.getElementById('task-chat-modal');
                                if (chatModal && chatModal.classList.contains('active')) {
                                    renderChatMessages();
                                    console.log('üí¨ Worker: Chat refreshed via BroadcastChannel');
                                }

                                updateChatBadge();
                            }
                        }
                    }
                }
            }
        };

        // ===== SYNC STATUS & NOTIFICATIONS =====
        function updateSyncStatus(status = 'synced') {
            const dot = document.getElementById('sync-dot');
            const text = document.getElementById('sync-text');

            dot.className = 'status-dot';

            switch(status) {
                case 'synced':
                    dot.classList.add('synced');
                    text.textContent = 'Synced';
                    break;
                case 'syncing':
                    dot.classList.add('syncing');
                    text.textContent = 'Syncing...';
                    break;
                case 'offline':
                    dot.classList.add('offline');
                    text.textContent = 'Offline';
                    break;
            }
        }

        function updatePendingUploads() {
            const count = hubState.syncQueue ? hubState.syncQueue.filter(item => item.actionType === 'uploadMedia').length : 0;
            const indicator = document.getElementById('upload-indicator');
            const badge = document.getElementById('pending-count');

            if (count > 0) {
                indicator.style.display = 'flex';
                badge.textContent = count;
            } else {
                indicator.style.display = 'none';
            }
        }

        function showToast(message, type = 'info', duration = 3000) {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            const icon = type === 'success' ? '‚úì' : type === 'warning' ? '‚ö†' : '‚Ñπ';
            toast.innerHTML = `
                <span style="font-size: 20px;">${icon}</span>
                <span>${message}</span>
            `;

            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease reverse';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        function checkForNewTasks() {
            // Called when state updates - checks if new tasks were added
            if (!selectedProject || !currentUser) return;

            const project = hubState.projects?.find(p => p.id == selectedProject.id);
            if (!project) return;

            let newTaskCount = 0;
            if (project.areas) {
                project.areas.forEach(area => {
                    if (area.tasks) {
                        area.tasks.forEach(task => {
                            // Check if task is assigned to me, not completed, and recently added (within last 5 mins)
                            if (isTaskAssignedToMe(task) &&
                                !task.completed &&
                                task.createdAt) {
                                const taskAge = Date.now() - new Date(task.createdAt).getTime();
                                if (taskAge < 5 * 60 * 1000) { // Less than 5 minutes old
                                    newTaskCount++;
                                }
                            }
                        });
                    }
                });
            }

            if (newTaskCount > 0) {
                showToast(`${newTaskCount} new task${newTaskCount > 1 ? 's' : ''} assigned to you!`, 'info', 5000);
            }
        }

        // ===== NOTIFICATION CENTER =====
        let notifications = [];
        let unreadCount = 0;

        function loadNotifications() {
            const saved = localStorage.getItem('worker_notifications');
            if (saved) {
                notifications = JSON.parse(saved);
                updateNotificationBadge();
                renderNotifications();
            }
        }

        function saveNotifications() {
            // Keep last 50 notifications
            if (notifications.length > 50) {
                notifications = notifications.slice(-50);
            }
            localStorage.setItem('worker_notifications', JSON.stringify(notifications));
        }

        function addNotification(activity, userName) {
            // Don't add notification from ourselves
            if (userName === currentUser?.name) return;

            const notification = {
                id: Date.now().toString(),
                type: activity.type,
                user: userName,
                message: activity.message,
                details: activity.details || {},
                timestamp: new Date().toISOString(),
                read: false
            };

            notifications.unshift(notification);
            unreadCount++;

            saveNotifications();
            updateNotificationBadge();
            renderNotifications();
        }

        function updateNotificationBadge() {
            unreadCount = notifications.filter(n => !n.read).length;
            const badge = document.getElementById('notification-badge');
            if (badge) {
                badge.textContent = unreadCount;
                badge.classList.toggle('hidden', unreadCount === 0);
            }
        }

        function toggleNotificationCenter() {
            const center = document.getElementById('notification-center');
            center.classList.toggle('active');
        }

        function markAllAsRead() {
            notifications.forEach(n => n.read = true);
            unreadCount = 0;
            saveNotifications();
            updateNotificationBadge();
            renderNotifications();
        }

        function markAsRead(notifId) {
            const notif = notifications.find(n => n.id === notifId);
            if (notif && !notif.read) {
                notif.read = true;
                unreadCount = Math.max(0, unreadCount - 1);
                saveNotifications();
                updateNotificationBadge();
                renderNotifications();
            }
        }

        function getNotificationIcon(type) {
            const icons = {
                'TASK_ASSIGNED': 'üìã',
                'TASK_UPDATED': 'üìù',
                'TASK_CREATED': '‚ú®',
                'TASK_PRIORITY_CHANGED': '‚ö†Ô∏è',
                'TASK_MESSAGE': 'üí¨',
                'AREA_CREATED': 'üìç',
                'MANAGER_COMMENT': 'üí¨',
                'PROJECT_UPDATE': 'üìä',
                'CALENDAR_EVENT': 'üìÖ',
                'TOOL_AVAILABLE': 'üîß'
            };
            return icons[type] || '‚ÑπÔ∏è';
        }

        function getRelativeTime(timestamp) {
            const now = new Date();
            const then = new Date(timestamp);
            const seconds = Math.floor((now - then) / 1000);

            if (seconds < 60) return 'Just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        }

        function renderNotifications() {
            const body = document.getElementById('notif-center-body');
            if (!body) return;

            if (notifications.length === 0) {
                body.innerHTML = `
                    <div class="empty-state">
                        <div style="font-size: 48px; margin-bottom: 12px;">üîî</div>
                        <div>No notifications</div>
                    </div>
                `;
                return;
            }

            let html = '';
            notifications.forEach(notif => {
                const icon = getNotificationIcon(notif.type);
                const time = getRelativeTime(notif.timestamp);
                const unreadClass = notif.read ? '' : 'unread';

                html += `
                    <div class="notif-item ${unreadClass}" onclick="markAsRead('${notif.id}')">
                        <div class="notif-item-header">
                            <span class="notif-item-icon">${icon}</span>
                            <span class="notif-item-user">${notif.user}</span>
                            <span class="notif-item-time">${time}</span>
                        </div>
                        <div class="notif-item-message">${notif.message}</div>
                    </div>
                `;
            });

            body.innerHTML = html;
        }

        // Close notification center when clicking outside
        document.addEventListener('click', (e) => {
            const center = document.getElementById('notification-center');
            const bell = document.getElementById('notification-bell');

            if (center && bell && center.classList.contains('active')) {
                if (!center.contains(e.target) && !bell.contains(e.target)) {
                    center.classList.remove('active');
                }
            }
        });

        // ===== TASK CHAT FUNCTIONS =====
        function openTaskChat() {
            if (!currentTask) return;

            // Initialize conversation if it doesn't exist
            if (!currentTask.conversation) {
                currentTask.conversation = {
                    messages: [],
                    participants: [currentUser.name]
                };
            }

            // Update chat header
            document.getElementById('chat-task-name').textContent = currentTask.name;
            document.getElementById('chat-task-info').textContent = `${currentTask.areaName} ‚Ä¢ ${currentTask.projectName || 'Project'}`;

            // Render messages
            renderChatMessages();

            // Mark all messages as read
            markChatMessagesRead();

            // Show modal
            document.getElementById('task-chat-modal').classList.add('active');

            // Start polling for new messages (like WhatsApp/Slack)
            startChatPolling();

            // Focus input
            setTimeout(() => {
                document.getElementById('chat-input').focus();
            }, 100);
        }

        function closeTaskChat() {
            document.getElementById('task-chat-modal').classList.remove('active');
            document.getElementById('chat-input').value = '';

            // Stop polling when chat is closed
            stopChatPolling();
        }

        function startChatPolling() {
            // Clear any existing interval
            stopChatPolling();

            console.log('üí¨ Worker: Starting chat polling (checking every 2 seconds)');

            // Store initial message count
            lastMessageCount = currentTask.conversation?.messages?.length || 0;

            // Poll every 2 seconds for new messages
            chatPollInterval = setInterval(() => {
                refreshChatMessages();
            }, 2000);
        }

        function stopChatPolling() {
            if (chatPollInterval) {
                clearInterval(chatPollInterval);
                chatPollInterval = null;
                console.log('üí¨ Worker: Stopped chat polling');
            }
        }

        function refreshChatMessages() {
            // Reload hub state to get latest messages
            const stateStr = localStorage.getItem('pmSystemState');
            if (!stateStr) return;

            hubState = JSON.parse(stateStr);

            // Find the updated task
            const project = hubState.projects?.find(p => p.id == currentTask.projectId);
            if (!project) return;

            const area = project.areas?.find(a => a.id == currentTask.areaId);
            if (!area) return;

            const updatedTask = area.tasks?.find(t => t.wbs == currentTask.wbs);
            if (!updatedTask) return;

            // Check if there are new messages
            const newMessageCount = updatedTask.conversation?.messages?.length || 0;

            if (newMessageCount > lastMessageCount) {
                console.log(`üí¨ Worker: ${newMessageCount - lastMessageCount} new message(s) detected`);

                // Update currentTask with new data
                currentTask = {
                    ...updatedTask,
                    projectId: project.id,
                    projectName: project.name,
                    areaId: area.id,
                    areaName: area.name
                };

                // Re-render messages
                renderChatMessages();

                // Mark new messages as read
                markChatMessagesRead();

                // Update count
                lastMessageCount = newMessageCount;
            }
        }

        function renderChatMessages() {
            const container = document.getElementById('chat-messages');

            if (!currentTask.conversation || currentTask.conversation.messages.length === 0) {
                container.innerHTML = `
                    <div class="chat-empty">
                        <div class="chat-empty-icon">üí¨</div>
                        <div>No messages yet</div>
                        <div style="font-size: 13px; margin-top: 8px;">Start a conversation about this task</div>
                    </div>
                `;
                return;
            }

            let html = '';
            currentTask.conversation.messages.forEach(msg => {
                const isOwn = msg.userId === currentUser.id;
                const messageClass = isOwn ? 'own' : 'other';
                const time = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                html += `
                    <div class="chat-message ${messageClass}">
                        <div class="chat-message-header">
                            <span class="chat-message-user">${msg.userName}</span>
                            <span class="chat-message-time">${time}</span>
                        </div>
                        <div class="chat-message-bubble">${escapeHtml(msg.text)}</div>
                    </div>
                `;
            });

            container.innerHTML = html;

            // Scroll to bottom
            container.scrollTop = container.scrollHeight;
        }

        async function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const text = input.value.trim();

            if (!text || !currentTask) return;

            // Initialize conversation if needed
            if (!currentTask.conversation) {
                currentTask.conversation = {
                    messages: [],
                    participants: [currentUser.name]
                };
            }

            // Add participant if not already in list
            if (!currentTask.conversation.participants.includes(currentUser.name)) {
                currentTask.conversation.participants.push(currentUser.name);
            }

            // Create message
            const message = {
                id: Date.now().toString(),
                userId: currentUser.id,
                userName: currentUser.name,
                text: text,
                timestamp: new Date().toISOString(),
                readBy: [currentUser.id]
            };

            // Add to conversation
            currentTask.conversation.messages.push(message);

            // Update task in hubState
            const project = hubState.projects.find(p => p.id == currentTask.projectId);
            if (project) {
                const area = project.areas.find(a => a.id == currentTask.areaId);
                if (area) {
                    const task = area.tasks.find(t => t.wbs == currentTask.wbs);
                    if (task) {
                        task.conversation = currentTask.conversation;
                    }
                }
            }

            // Log activity for notifications
            logActivity('TASK_MESSAGE', `New message in: ${currentTask.name}`, {
                taskName: currentTask.name,
                taskWbs: currentTask.wbs,
                assignee: currentTask.assignee,
                message: text.substring(0, 100) // First 100 chars
            });

            // Save and sync
            await saveHubState('projects');

            // Clear input
            input.value = '';

            // Re-render
            renderChatMessages();

            showToast('Message sent!', 'success', 2000);
        }

        function handleChatKeydown(event) {
            // Send on Enter (but allow Shift+Enter for new line)
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChatMessage();
            }
        }

        function markChatMessagesRead() {
            if (!currentTask || !currentTask.conversation) return;

            let hasUnread = false;

            currentTask.conversation.messages.forEach(msg => {
                if (!msg.readBy) msg.readBy = [];
                if (!msg.readBy.includes(currentUser.id)) {
                    msg.readBy.push(currentUser.id);
                    hasUnread = true;
                }
            });

            if (hasUnread) {
                // Update in hubState
                const project = hubState.projects.find(p => p.id == currentTask.projectId);
                if (project) {
                    const area = project.areas.find(a => a.id == currentTask.areaId);
                    if (area) {
                        const task = area.tasks.find(t => t.wbs == currentTask.wbs);
                        if (task) {
                            task.conversation = currentTask.conversation;
                        }
                    }
                }

                // Save (no broadcast needed for read receipts)
                saveHubState('projects', false); // false = don't broadcast
            }

            updateChatBadge();
        }

        function updateChatBadge() {
            if (!currentTask || !currentTask.conversation) {
                document.getElementById('task-chat-badge').classList.add('hidden');
                return;
            }

            const unreadCount = currentTask.conversation.messages.filter(msg => {
                return !msg.readBy || !msg.readBy.includes(currentUser.id);
            }).length;

            const badge = document.getElementById('task-chat-badge');
            if (unreadCount > 0) {
                badge.textContent = unreadCount;
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Initialize
        function init() {
            // Get current user from login
            const userStr = localStorage.getItem('pm_hub_current_user');
            if (!userStr) {
                window.location.href = 'index.html';
                return;
            }

            currentUser = JSON.parse(userStr);

            // Redirect non-workers to their appropriate apps
            if (currentUser.accessLevel === 'Admin') {
                window.location.href = 'PM_Hub_CL_v01_024.html';
                return;
            }
            if (currentUser.accessLevel === 'Manager') {
                window.location.href = 'manager.html';
                return;
            }

            document.getElementById('worker-name').textContent = currentUser.name;

            // Start live clock
            startLiveClock();

            // Initialize Google APIs
            initGoogleAPIs();

            // Load hub state
            loadHubState();

            // Load notifications
            loadNotifications();

            // Update sync indicators
            updateSyncStatus(navigator.onLine ? 'synced' : 'offline');
            updatePendingUploads();

            // Check if already clocked in
            checkClockStatus();

            // Load projects
            loadProjects();
        }

        // ===== GOOGLE DRIVE INTEGRATION =====
        function initGoogleAPIs() {
            // Load GAPI
            if (typeof gapi !== 'undefined') {
                gapi.load('client', async () => {
                    try {
                        // DO NOT use API key - it forces key-based auth instead of OAuth token
                        await gapi.client.init({
                            discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest']
                        });
                        gapiInited = true;
                        console.log('Google Drive API initialized');

                        // Check for access token from login page
                        const loginToken = localStorage.getItem('drive_token_from_login');
                        if (loginToken) {
                            gapi.client.setToken({ access_token: loginToken });
                            accessToken = loginToken;
                            console.log('Using access token from login page');
                        }
                    } catch (error) {
                        console.error('GAPI init error:', error);
                    }
                });
            }

            // Load GIS
            if (typeof google !== 'undefined' && google.accounts) {
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: CLIENT_ID,
                    scope: SCOPES,
                    callback: (tokenResponse) => {
                        accessToken = tokenResponse.access_token;
                        console.log('Google Drive authenticated');
                    }
                });
                gisInited = true;
            }
        }

        function authorizeGoogleDrive() {
            if (!gisInited) {
                alert('Google API not loaded yet. Please refresh the page.');
                return;
            }
            tokenClient.requestAccessToken();
        }

        async function uploadToGoogleDrive(blob, filename, folderId) {
            if (!accessToken) {
                alert('Authorizing Google Drive...');
                authorizeGoogleDrive();
                return null;
            }

            const metadata = {
                name: filename,
                parents: folderId ? [folderId] : []
            };

            const form = new FormData();
            form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
            form.append('file', blob);

            try {
                const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    },
                    body: form
                });

                return await response.json();
            } catch (error) {
                console.error('Upload error:', error);
                return null;
            }
        }

        async function getTaskDriveFolder() {
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üîç getTaskDriveFolder() - DIAGNOSTIC START');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

            if (!currentTask) {
                console.warn('‚ùå No current task selected');
                return null;
            }

            console.log('üìå Current Task Info:');
            console.log('   - Name:', currentTask.name);
            console.log('   - WBS:', currentTask.wbs);
            console.log('   - Project ID:', currentTask.projectId);
            console.log('   - Area ID:', currentTask.areaId);

            // Reload hub state to get latest folder IDs
            loadHubState();
            console.log('‚úì Hub state reloaded');

            // Find project in hubState (not selectedProject reference)
            const project = hubState.projects?.find(p => p.id == currentTask.projectId);
            if (!project) {
                console.error('‚ùå Project not found in hub state');
                console.log('Available projects:', hubState.projects?.map(p => ({ id: p.id, name: p.name })));
                return null;
            }
            console.log('‚úì Project Found:', project.name);
            console.log('   - Project Drive Folder ID:', project.driveFolderId || 'MISSING');

            const area = project.areas?.find(a => a.id == currentTask.areaId);
            if (!area) {
                console.error('‚ùå Area not found');
                console.log('Available areas:', project.areas?.map(a => ({ id: a.id, name: a.name })));
                return null;
            }
            console.log('‚úì Area Found:', area.name);
            console.log('   - Area Drive Folder ID:', area.driveFolderId || 'MISSING');

            // Try to get task REPORTS folder (preferred)
            if (currentTask.wbs && area && area.tasks) {
                console.log('üîé Searching for task with WBS:', currentTask.wbs);
                console.log('   - Available tasks:', area.tasks.map(t => ({ wbs: t.wbs, name: t.name })));

                // Use loose equality to handle string/number comparison
                const task = area.tasks.find(t => t.wbs == currentTask.wbs);

                if (task) {
                    console.log('‚úì Task Found:', task.name);
                    console.log('   - Task Drive Folder ID:', task.driveFolderId || 'MISSING');
                    console.log('   - Task REPORTS Folder ID:', task.reportsFolderId || 'MISSING');

                    // Return REPORTS folder if it exists, otherwise task folder
                    if (task.reportsFolderId) {
                        console.log('‚úÖ SUCCESS: Using task REPORTS folder');
                        console.log('üìÅ FINAL FOLDER ID:', task.reportsFolderId);
                        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                        return task.reportsFolderId;
                    } else if (task.driveFolderId) {
                        console.log('‚ö†Ô∏è WARNING: No REPORTS folder, using task folder');
                        console.log('üìÅ FINAL FOLDER ID:', task.driveFolderId);
                        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                        return task.driveFolderId;
                    } else {
                        console.warn('‚ö†Ô∏è Task has no Drive folders at all!');
                    }
                } else {
                    console.error('‚ùå Task NOT found with WBS:', currentTask.wbs);
                }
            }

            // Fallback to area folder
            if (area && area.driveFolderId) {
                console.log('‚ö†Ô∏è FALLBACK: Using area folder');
                console.log('üìÅ FINAL FOLDER ID:', area.driveFolderId);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                return area.driveFolderId;
            }

            // Fallback to project folder
            if (project && project.driveFolderId) {
                console.log('‚ö†Ô∏è FALLBACK: Using project folder');
                console.log('üìÅ FINAL FOLDER ID:', project.driveFolderId);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                return project.driveFolderId;
            }

            console.error('‚ùå FAILURE: No Drive folder found anywhere!');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            return null;
        }

        // Live Clock Functions
        function startLiveClock() {
            updateLiveClock();
            setInterval(updateLiveClock, 1000);
        }

        function updateLiveClock() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const clockEl = document.getElementById('live-clock');
            if (clockEl) {
                clockEl.textContent = `${hours}:${minutes}:${seconds}`;
            }

            // Update date
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            const dateEl = document.getElementById('live-date');
            if (dateEl) {
                dateEl.textContent = now.toLocaleDateString('en-US', options);
            }
        }

        function loadHubState() {
            const stateStr = localStorage.getItem('pmSystemState');
            if (stateStr) {
                hubState = JSON.parse(stateStr);
            } else {
                hubState = { projects: [], tools: [], timeEntries: [], activities: [], reports: [] };
            }

            // Ensure offline sync properties exist
            if (!hubState.syncQueue) hubState.syncQueue = [];
            if (!hubState.isOnline) hubState.isOnline = navigator.onLine;
        }

        async function saveHubState(section = 'general') {
            // Show syncing status
            updateSyncStatus('syncing');

            // Update online status before saving
            hubState.isOnline = navigator.onLine;
            localStorage.setItem('pmSystemState', JSON.stringify(hubState));

            // Sync to Firebase if enabled
            if (window.firebaseEnabled && window.db) {
                try {
                    console.log('‚òÅÔ∏è Worker: Syncing to Firebase...');

                    // Clean data for Firebase (remove undefined/null, ensure arrays)
                    const cleanData = {
                        projects: Array.isArray(hubState.projects) ? hubState.projects : [],
                        ourTeam: Array.isArray(hubState.ourTeam) ? hubState.ourTeam : [],
                        clientTeam: Array.isArray(hubState.clientTeam) ? hubState.clientTeam : [],
                        clients: Array.isArray(hubState.clients) ? hubState.clients : [],
                        tools: Array.isArray(hubState.tools) ? hubState.tools : [],
                        activities: Array.isArray(hubState.activities) ? hubState.activities.slice(0, 100) : [], // Limit to 100 most recent
                        reports: Array.isArray(hubState.reports) ? hubState.reports.slice(0, 50) : [], // Limit to 50 most recent
                        timeEntries: Array.isArray(hubState.timeEntries) ? hubState.timeEntries : [],
                        lastModified: new Date().toISOString(),
                        lastSyncedBy: currentUser ? currentUser.name : 'worker'
                    };

                    await window.firestore.setDoc(
                        window.firestore.doc(window.db, 'hubs', 'main'),
                        cleanData,
                        { merge: true } // Use merge to avoid overwriting other fields
                    );
                    console.log('‚úì Worker: Synced to Firebase');
                } catch (error) {
                    console.error('‚ùå Worker: Firebase sync error:', error);
                    console.error('Error details:', error.message);
                }
            }

            // Get latest activity for notification
            const lastActivity = hubState.activities?.[hubState.activities.length - 1];

            // Broadcast state change to hub for instant sync (fallback)
            stateChannel.postMessage({
                type: 'STATE_UPDATED',
                section: section,
                timestamp: Date.now(),
                source: 'worker',
                syncedBy: currentUser ? currentUser.name : 'worker',
                activity: lastActivity
            });
            console.log('üì° Worker: Broadcasted state change -', section);

            // Also broadcast via realtime module for enhanced notifications
            if (window.pmRealtime && lastActivity) {
                window.pmRealtime.broadcast(section, lastActivity);
            }

            // Update indicators after sync
            updateSyncStatus('synced');
            updatePendingUploads();
        }

        function checkClockStatus() {
            // Check if user is currently clocked in
            if (!hubState.timeEntries) hubState.timeEntries = [];

            const today = new Date().toDateString();
            const todayEntries = hubState.timeEntries.filter(e =>
                e.userId === currentUser.id &&
                new Date(e.timestamp).toDateString() === today
            );

            const lastEntry = todayEntries[todayEntries.length - 1];
            if (lastEntry && lastEntry.type === 'in') {
                // User is clocked in
                selectedProject = hubState.projects.find(p => p.id == lastEntry.projectId);
                clockedInTime = new Date(lastEntry.timestamp);

                // Check if user has an in-progress task
                const inProgressTask = findInProgressTask();
                if (inProgressTask) {
                    // Resume the task they were working on
                    currentTask = inProgressTask;
                    console.log('‚úì Resuming in-progress task:', currentTask.name);
                    showActiveTask();
                } else {
                    // Show task selection
                    showTaskSelection();
                }

                document.getElementById('clock-out-fixed-btn').style.display = 'block';
            }
        }

        function findInProgressTask() {
            // Find any task assigned to this user that is currently in progress
            if (!selectedProject || !selectedProject.areas) return null;

            for (const area of selectedProject.areas) {
                if (!area.tasks) continue;
                for (const task of area.tasks) {
                    // Check if task is assigned to me, in progress, and not completed
                    if (isTaskAssignedToMe(task) &&
                        task.status === 'progress' &&
                        !task.completed &&
                        task.startedBy === currentUser.name) {
                        // Return full task object with context properties
                        return {
                            ...task, // Copy all task properties including conversation
                            projectId: selectedProject.id,
                            projectName: selectedProject.name,
                            areaId: area.id,
                            areaName: area.name
                        };
                    }
                }
            }
            return null;
        }

        function loadProjects() {
            const select = document.getElementById('project-select');
            select.innerHTML = '<option value="">-- Choose Project --</option>';

            if (hubState.projects) {
                // SMART FILTER: Only show projects that have tasks assigned to this worker
                hubState.projects.forEach(p => {
                    if (projectHasMyTasks(p)) {
                        select.innerHTML += `<option value="${p.id}">${p.name}</option>`;
                    }
                });
            }
        }

        function projectHasMyTasks(project) {
            if (!project.areas) return false;

            for (const area of project.areas) {
                if (!area.tasks) continue;
                for (const task of area.tasks) {
                    // Check if task is assigned to me and not completed
                    // Use == for flexible comparison (could be id or name, string or number)
                    if (isTaskAssignedToMe(task) && !task.completed) {
                        return true;
                    }
                }
            }
            return false;
        }

        function enableClockIn() {
            const projectId = document.getElementById('project-select').value;
            document.getElementById('clock-in-btn').disabled = !projectId;
        }

        async function clockIn() {
            const projectId = document.getElementById('project-select').value;
            if (!projectId) return;

            selectedProject = hubState.projects.find(p => p.id == projectId);
            clockedInTime = new Date();

            // Save time entry
            if (!hubState.timeEntries) hubState.timeEntries = [];
            hubState.timeEntries.push({
                id: Date.now().toString(),
                userId: currentUser.id,
                userName: currentUser.name,
                projectId: projectId,
                type: 'in',
                timestamp: clockedInTime.toISOString()
            });

            // Log activity
            logActivity('CLOCK_IN', `Clocked in to ${selectedProject.name}`);

            await saveHubState();
            showTaskSelection();
            document.getElementById('clock-out-fixed-btn').style.display = 'block';
        }

        function showTaskSelection() {
            document.getElementById('clock-in-screen').classList.add('hidden');
            document.getElementById('active-task-screen').classList.add('hidden');
            document.getElementById('task-selection-screen').classList.remove('hidden');
            document.getElementById('clocked-project-name').textContent = selectedProject.name;

            // Load areas - SMART FILTER: Only areas with MY tasks
            const areaSelect = document.getElementById('area-select');
            areaSelect.innerHTML = '<option value="">-- Select Area --</option>';

            if (selectedProject.areas) {
                selectedProject.areas.forEach(area => {
                    if (areaHasMyTasks(area)) {
                        areaSelect.innerHTML += `<option value="${area.id}">${area.name}</option>`;
                    }
                });
            }

            // Reset button text
            const startBtn = document.getElementById('start-task-btn');
            startBtn.textContent = '‚ñ∂Ô∏è Start Task';
        }

        function areaHasMyTasks(area) {
            if (!area.tasks) return false;

            for (const task of area.tasks) {
                // Check if task is assigned to me and not completed
                if (isTaskAssignedToMe(task) && !task.completed) {
                    return true;
                }
            }
            return false;
        }

        function loadTasksForArea() {
            const areaId = document.getElementById('area-select').value;
            const taskSelectGroup = document.getElementById('task-select-group');
            const taskSelect = document.getElementById('task-select-dropdown');
            const startBtn = document.getElementById('start-task-btn');

            if (!areaId) {
                taskSelectGroup.classList.add('hidden');
                startBtn.disabled = true;
                return;
            }

            const area = selectedProject.areas.find(a => a.id == areaId);
            if (!area || !area.tasks || area.tasks.length === 0) {
                taskSelectGroup.classList.add('hidden');
                startBtn.disabled = false; // Can start area without specific task
                return;
            }

            // Show tasks - SMART FILTER: Only MY incomplete tasks
            taskSelectGroup.classList.remove('hidden');
            taskSelect.innerHTML = '<option value="">-- Select Task --</option>';

            let myTasksCount = 0;
            area.tasks.forEach(task => {
                // Only show tasks assigned to ME that are NOT completed
                // Check if task is assigned to current user
                if (isTaskAssignedToMe(task) && !task.completed) {
                    const priorityIcon = task.priority === 'high' ? 'üî¥' : task.priority === 'medium' ? 'üü°' : 'üü¢';
                    const isInProgress = task.status === 'progress' && task.startedBy === currentUser.name;
                    const statusText = isInProgress ? ' üîÑ (CONTINUE)' : '';
                    taskSelect.innerHTML += `<option value="${task.wbs}">${priorityIcon} ${task.wbs} - ${task.name}${statusText}</option>`;
                    myTasksCount++;
                }
            });

            if (myTasksCount === 0) {
                taskSelectGroup.classList.add('hidden');
                startBtn.disabled = false; // Can still work on area generally
            } else {
                taskSelect.onchange = () => {
                    const selectedWbs = taskSelect.value;
                    startBtn.disabled = !selectedWbs;

                    // Update button text based on task status
                    if (selectedWbs) {
                        const task = area.tasks.find(t => t.wbs == selectedWbs);
                        if (task && task.status === 'progress' && task.startedBy === currentUser.name) {
                            startBtn.textContent = 'üîÑ Continue Task';
                        } else {
                            startBtn.textContent = '‚ñ∂Ô∏è Start Task';
                        }
                    }
                };
            }
        }

        async function startSelectedTask() {
            const areaId = document.getElementById('area-select').value;
            if (!areaId) {
                alert('Please select an area');
                return;
            }

            // Find project in hubState (not selectedProject reference)
            const project = hubState.projects.find(p => p.id == selectedProject.id);
            if (!project) {
                alert('Project not found');
                return;
            }

            const area = project.areas.find(a => a.id == areaId);
            if (!area) {
                alert('Area not found');
                return;
            }

            const taskWbs = document.getElementById('task-select-dropdown').value;

            if (taskWbs) {
                // Starting a specific task
                if (!area.tasks || area.tasks.length === 0) {
                    alert('No tasks found in this area');
                    return;
                }

                // Use loose equality to handle string/number comparison
                const task = area.tasks.find(t => t.wbs == taskWbs);
                if (!task) {
                    console.error('Task not found. Looking for WBS:', taskWbs);
                    console.error('Available tasks:', area.tasks.map(t => ({ wbs: t.wbs, name: t.name })));
                    alert('Task not found. Please try again or contact support.');
                    return;
                }

                // Only update start time if task is not already in progress
                const isContinuing = task.status === 'progress' && task.startedBy === currentUser.name;
                if (!isContinuing) {
                    task.status = 'progress';
                    task.startedAt = new Date().toISOString();
                    task.startedBy = currentUser.name;
                    console.log('‚úì Task started:', task.name, '| Status:', task.status, '| WBS:', task.wbs);
                } else {
                    console.log('üîÑ Continuing task:', task.name, '| WBS:', task.wbs);
                }

                // Store full task object with all properties (including conversation)
                currentTask = {
                    ...task, // Copy all task properties
                    projectId: project.id,
                    projectName: project.name,
                    areaId: areaId,
                    areaName: area.name
                };

                if (isContinuing) {
                    logActivity('TASK_CONTINUE', `Continuing: ${task.name}`);
                } else {
                    logActivity('TASK_START', `Started: ${task.name}`);
                }
            } else {
                // Starting area without specific task (general work)
                currentTask = {
                    projectId: project.id,
                    areaId: areaId,
                    areaName: area.name,
                    wbs: null,
                    name: area.name
                };

                logActivity('TASK_START', `Started working on: ${area.name}`);
            }

            await saveHubState('projects'); // Broadcast task start to hub
            showActiveTask();
        }

        function showActiveTask() {
            document.getElementById('task-selection-screen').classList.add('hidden');
            document.getElementById('active-task-screen').classList.remove('hidden');
            document.getElementById('current-task-name').textContent = currentTask.name;
            document.getElementById('current-task-area').textContent = `Area: ${currentTask.areaName}`;

            // Update chat badge
            updateChatBadge();
        }

        async function completeCurrentTask() {
            if (!currentTask) return;

            // Find project in hubState (not selectedProject reference)
            const project = hubState.projects.find(p => p.id == currentTask.projectId);
            if (!project) {
                alert('Project not found');
                return;
            }

            const area = project.areas.find(a => a.id == currentTask.areaId);
            if (!area) {
                alert('Area not found');
                return;
            }

            if (currentTask.wbs) {
                // Use loose equality to handle string/number comparison
                const task = area.tasks.find(t => t.wbs == currentTask.wbs);
                if (!task) {
                    alert('Task not found');
                    return;
                }

                // Calculate actual hours
                let actualHours = task.estimatedHours || 0;
                if (task.startedAt) {
                    const started = new Date(task.startedAt);
                    const completed = new Date();
                    const hoursWorked = (completed - started) / (1000 * 60 * 60);
                    actualHours = Math.round(hoursWorked * 10) / 10;
                }

                task.status = 'done';
                task.completed = true;
                task.completedAt = new Date().toISOString();
                task.completedBy = currentUser.name;
                task.actualHours = actualHours;

                console.log('‚úì Task marked as completed:', task.name, '| Status:', task.status, '| WBS:', task.wbs, '| Hours:', actualHours);

                logActivity('TASK_COMPLETE', `Completed: ${task.name}`, {
                    hours: actualHours,
                    billable: area.billable,
                    taskName: task.name,
                    projectCode: project.code,
                    areaName: area.name,
                    completedBy: currentUser.name
                });

                // Check if area is complete
                const allTasks = area.tasks || [];
                const completedTasks = allTasks.filter(t => t.completed);
                if (allTasks.length > 0 && completedTasks.length === allTasks.length) {
                    logActivity('AREA_COMPLETE', `Area "${area.name}" is 100% complete`, {
                        billable: area.billable,
                        requiresInvoice: area.billable
                    });
                }
            }

            await saveHubState('projects'); // Broadcast task completion to hub
            currentTask = null;

            // Smart navigation: Check if there are more tasks available
            checkForNextTask();
        }

        function checkForNextTask() {
            // Reload the latest hub state
            loadHubState();

            // Re-find the selected project with latest data
            selectedProject = hubState.projects?.find(p => p.id == selectedProject.id);

            if (!selectedProject) {
                // Project no longer exists
                showNoWorkAvailable('Project no longer available. Please clock in to a new project.');
                return;
            }

            // Check if this project has any incomplete tasks assigned to me
            let hasMyTasks = false;
            let nextTask = null;

            if (selectedProject.areas) {
                for (const area of selectedProject.areas) {
                    if (area.tasks) {
                        const myIncompleteTasks = area.tasks.filter(t =>
                            isTaskAssignedToMe(t) && !t.completed
                        );

                        if (myIncompleteTasks.length > 0) {
                            hasMyTasks = true;
                            nextTask = myIncompleteTasks[0]; // Get first available task
                            break;
                        }
                    }
                }
            }

            if (hasMyTasks && nextTask) {
                // Show task selection screen with available tasks
                showTaskSelection();
            } else {
                // No more tasks assigned to me
                showNoWorkAvailable('All your tasks are complete! üéâ');
            }
        }

        function showNoWorkAvailable(message) {
            document.getElementById('task-selection-screen').classList.add('hidden');
            document.getElementById('active-task-screen').classList.add('hidden');

            // Show a clean "no work" screen
            const clockInScreen = document.getElementById('clock-in-screen');
            clockInScreen.classList.remove('hidden');
            clockInScreen.innerHTML = `
                <div style="text-align: center; padding: 40px 20px;">
                    <div style="font-size: 48px; margin-bottom: 20px;">‚úÖ</div>
                    <h2 style="margin-bottom: 16px; color: var(--text-primary);">${message}</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 24px;">
                        Your project manager has been notified. You can clock out or wait for new tasks to be assigned.
                    </p>
                    <button onclick="requestClockOut()" class="big-btn" style="background: var(--accent-primary); margin-bottom: 12px;">
                        ‚è∞ Clock Out
                    </button>
                    <button onclick="checkForNextTask()" class="big-btn" style="background: var(--glass-bg);">
                        üîÑ Check for New Tasks
                    </button>
                </div>
            `;

            // Log activity to notify PM
            logActivity('AWAITING_TASKS', `${currentUser.name} has completed all assigned tasks and is awaiting new work`, {
                project: selectedProject.code,
                projectCode: selectedProject.code,
                userName: currentUser.name,
                workerName: currentUser.name
            });
        }

        function showReportModal() {
            document.getElementById('report-modal').style.display = 'block';
            document.getElementById('report-text').value = '';
            resetCameraUI();
        }

        async function submitReport() {
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üì§ SUBMIT REPORT - DIAGNOSTIC START');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

            const text = document.getElementById('report-text').value.trim();

            console.log('üìù Report text length:', text.length);
            console.log('üì∑ Captured media count:', capturedMedia.length);
            console.log('üìÇ Media files:', capturedMedia.map(m => m.filename));

            if (!text && capturedMedia.length === 0) {
                alert('Please enter text or capture media');
                return;
            }

            // Show loading indicator
            const submitBtn = document.querySelector('#report-modal .btn-primary');
            const originalText = submitBtn ? submitBtn.textContent : '';
            if (submitBtn) {
                submitBtn.textContent = '‚è≥ Uploading...';
                submitBtn.disabled = true;
            }

            // Upload media to Drive if exists
            let uploadedFiles = [];
            let mediaStoredLocally = false;
            let reportsFolderId = null; // Store folder ID for activity logging

            if (capturedMedia.length > 0 || text) {
                console.log('‚úÖ Report data detected - starting upload process');
                console.log('   Text length:', text.length);
                console.log('   Media files:', capturedMedia.length);

                // Check for token from login page first
                if (!accessToken) {
                    console.log('‚ö†Ô∏è No accessToken - checking localStorage...');
                    const loginToken = localStorage.getItem('drive_token_from_login');
                    console.log('   - loginToken from localStorage:', loginToken ? loginToken.substring(0, 20) + '...' : 'NULL');
                    if (loginToken) {
                        accessToken = loginToken;
                        gapi.client.setToken({ access_token: loginToken });
                        console.log('‚úì Using token from login page');
                    } else {
                        console.error('‚ùå No token found in localStorage');
                        console.error('   User must authorize Google Drive at login screen');
                    }
                } else {
                    console.log('‚úÖ accessToken already exists:', accessToken.substring(0, 20) + '...');
                }

                console.log('üåê Online status:', navigator.onLine);
                console.log('üîë Access token exists:', !!accessToken);
                console.log('üîë Access token value:', accessToken ? accessToken.substring(0, 20) + '...' : 'NULL');

                // Only upload if online AND authorized
                if (navigator.onLine && accessToken) {
                    console.log('‚úÖ CONDITIONS MET - Starting upload process');
                    // Reload hub state to get latest folder IDs
                    loadHubState();
                    console.log('üîÑ Reloaded hub state for latest folder info');

                    console.log('üéØ Calling getTaskDriveFolder()...');
                    const folderId = await getTaskDriveFolder();
                    reportsFolderId = folderId; // Save for activity logging
                    console.log('üìÅ Upload folder ID returned:', folderId);

                    if (folderId) {
                        // Upload text report as .txt file if exists
                        if (text) {
                            try {
                                console.log('‚¨ÜÔ∏è Uploading text report...');
                                const now = new Date();
                                const textFilename = `report_${now.toISOString().replace(/[:.]/g,'-')}.txt`;

                                // Create text content with metadata
                                const reportContent = `Project Management System - Work Report
Generated: ${now.toLocaleString()}
Worker: ${currentUser.name}
Project: ${selectedProject ? selectedProject.name : 'N/A'}
Task: ${currentTask ? currentTask.name : 'General'}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
REPORT:
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

${text}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
End of Report
`;

                                const textBlob = new Blob([reportContent], { type: 'text/plain' });
                                console.log('   - Filename:', textFilename);
                                console.log('   - Size:', textBlob.size, 'bytes');
                                console.log('   - Target folder:', folderId);

                                const uploadResult = await uploadToGoogleDrive(textBlob, textFilename, folderId);

                                if (uploadResult && uploadResult.id) {
                                    uploadedFiles.push({
                                        filename: textFilename,
                                        driveFileId: uploadResult.id,
                                        type: 'text'
                                    });
                                    console.log('‚úÖ Text report uploaded! File ID:', uploadResult.id);
                                } else {
                                    console.error('‚ùå Text upload result:', uploadResult);
                                }
                            } catch (error) {
                                console.error('‚ùå Text upload failed:', error);
                                mediaStoredLocally = true;
                            }
                        }

                        // Upload each media file
                        for (let i = 0; i < capturedMedia.length; i++) {
                            const media = capturedMedia[i];
                            try {
                                console.log(`‚¨ÜÔ∏è Uploading file ${i+1}/${capturedMedia.length}...`);
                                console.log('   - Filename:', media.filename);
                                console.log('   - Blob size:', media.blob.size, 'bytes');
                                console.log('   - Target folder:', folderId);

                                const uploadResult = await uploadToGoogleDrive(media.blob, media.filename, folderId);

                                console.log('üì• Upload result:', uploadResult);

                                if (uploadResult && uploadResult.id) {
                                    uploadedFiles.push({
                                        filename: media.filename,
                                        driveFileId: uploadResult.id,
                                        type: media.type
                                    });
                                    console.log(`‚úÖ File ${i+1} uploaded! File ID:`, uploadResult.id);
                                } else {
                                    console.error('‚ùå Upload result:', uploadResult);
                                    throw new Error('Upload result missing ID');
                                }
                            } catch (error) {
                                console.error(`‚ùå Upload failed for file ${i+1}:`, error);
                                // Store locally for later upload
                                mediaStoredLocally = true;
                                storeMediaForLaterUpload(media.blob, media.filename, currentTask);
                            }
                        }

                        if (uploadedFiles.length > 0) {
                            console.log(`‚úÖ‚úÖ‚úÖ ${uploadedFiles.length}/${capturedMedia.length} FILES UPLOADED!`);
                            showToast(`${uploadedFiles.length} file(s) uploaded to Drive!`, 'success');
                        }
                        if (uploadedFiles.length < capturedMedia.length) {
                            showToast(`${capturedMedia.length - uploadedFiles.length} file(s) saved locally`, 'warning');
                        }
                    } else {
                        console.error('‚ùå No folder ID returned from getTaskDriveFolder()');
                        // Store all media locally
                        capturedMedia.forEach(media => {
                            storeMediaForLaterUpload(media.blob, media.filename, currentTask);
                        });
                        mediaStoredLocally = true;
                        alert('‚ö†Ô∏è No Drive folder found. Media saved locally.');
                    }
                } else if (!accessToken && navigator.onLine) {
                    console.error('‚ùå Cannot upload - not authorized');
                    if (submitBtn) {
                        submitBtn.textContent = originalText;
                        submitBtn.disabled = false;
                    }
                    alert('Google Drive not authorized. Please reconnect at login screen.');
                    return;
                } else {
                    console.warn('‚ö†Ô∏è Cannot upload - offline');
                    // Offline - store all media locally
                    capturedMedia.forEach(media => {
                        storeMediaForLaterUpload(media.blob, media.filename, currentTask);
                    });
                    mediaStoredLocally = true;
                    alert('üì¥ Offline - Media saved locally and will upload when online');
                }
            } else {
                console.log('‚ÑπÔ∏è No captured media - text-only report');
            }

            // Save report to hubState
            if (!hubState.reports) hubState.reports = [];

            // Get project info from currentTask or hubState
            const projectInfo = currentTask && currentTask.projectId
                ? hubState.projects?.find(p => p.id == currentTask.projectId)
                : null;

            hubState.reports.push({
                id: Date.now().toString(),
                userId: currentUser.id,
                userName: currentUser.name,
                projectId: currentTask ? currentTask.projectId : null,
                projectName: projectInfo ? projectInfo.name : null,
                areaId: currentTask ? currentTask.areaId : null,
                areaName: currentTask ? currentTask.areaName : null,
                taskId: currentTask ? currentTask.wbs : null,
                taskName: currentTask ? currentTask.name : null,
                text: text,
                mediaFiles: uploadedFiles, // Array of {filename, driveFileId, type}
                mediaCount: capturedMedia.length,
                uploadedCount: uploadedFiles.length,
                mediaStoredLocally: mediaStoredLocally,
                reportsFolderId: reportsFolderId, // Store the folder ID for linking
                timestamp: new Date().toISOString()
            });

            logActivity('REPORT', text || 'Sent media report', {
                mediaCount: capturedMedia.length,
                uploadedCount: uploadedFiles.length,
                task: currentTask ? currentTask.name : 'General',
                uploaded: !mediaStoredLocally,
                reportsFolderId: reportsFolderId, // Add folder ID to activity for Hub linking
                driveFileId: uploadedFiles.length > 0 ? uploadedFiles[0].driveFileId : null // First file for quick access
            });

            await saveHubState();

            // Reset button state
            if (submitBtn) {
                submitBtn.textContent = originalText;
                submitBtn.disabled = false;
            }

            closeReportModal();

            console.log('üìä Report submission summary:');
            console.log('   - Total media files:', capturedMedia.length);
            console.log('   - Successfully uploaded:', uploadedFiles.length);
            console.log('   - Stored locally:', mediaStoredLocally);
            console.log('   - Report saved to hubState');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üì§ SUBMIT REPORT - COMPLETE');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

            if (!mediaStoredLocally || capturedMedia.length === 0) {
                showToast('Report submitted successfully!', 'success');
            }
        }

        // ===== CAMERA & MEDIA CAPTURE =====
        function showReportModal() {
            document.getElementById('report-modal').style.display = 'block';
            document.getElementById('report-text').value = '';
            capturedMedia = [];
            updateMediaGallery();
            resetCameraUI();
        }

        function closeReportModal() {
            closeCamera();
            document.getElementById('report-modal').style.display = 'none';
            capturedMedia = [];
        }

        function resetCameraUI() {
            document.getElementById('camera-preview-container').style.display = 'none';
            document.getElementById('start-camera-btn').style.display = 'block';
            document.getElementById('switch-camera-btn').style.display = 'none';
            document.getElementById('take-photo-btn').style.display = 'none';
            document.getElementById('start-record-btn').style.display = 'none';
            document.getElementById('stop-record-btn').style.display = 'none';
            document.getElementById('close-camera-btn').style.display = 'none';
        }

        function updateMediaGallery() {
            const gallery = document.getElementById('media-gallery');
            const container = document.getElementById('media-gallery-container');
            const count = document.getElementById('media-count');

            if (capturedMedia.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';
            count.textContent = `${capturedMedia.length} file${capturedMedia.length > 1 ? 's' : ''}`;

            gallery.innerHTML = '';

            capturedMedia.forEach((media, index) => {
                const card = document.createElement('div');
                card.style.cssText = 'position: relative; border-radius: 8px; overflow: hidden; background: rgba(0,0,0,0.5); aspect-ratio: 1; border: 1px solid var(--glass-border);';

                const preview = media.type === 'photo'
                    ? `<img src="${media.preview}" style="width: 100%; height: 100%; object-fit: cover;">`
                    : `<div style="display: flex; align-items: center; justify-content: center; height: 100%; font-size: 32px;">üé•</div>`;

                const typeLabel = media.type === 'photo' ? 'üì∏' : 'üé•';
                const sizeKB = Math.round(media.blob.size / 1024);

                card.innerHTML = `
                    ${preview}
                    <div style="position: absolute; top: 4px; left: 4px; background: rgba(0,0,0,0.7); padding: 2px 6px; border-radius: 4px; font-size: 11px;">
                        ${typeLabel} ${sizeKB}KB
                    </div>
                    <button onclick="removeMedia(${index})" style="position: absolute; top: 4px; right: 4px; width: 24px; height: 24px; border-radius: 50%; background: var(--accent-danger); border: none; color: white; font-size: 14px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-weight: bold;">√ó</button>
                `;

                gallery.appendChild(card);
            });
        }

        function removeMedia(index) {
            capturedMedia.splice(index, 1);
            updateMediaGallery();
        }

        function closeCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
            const video = document.getElementById('camera-preview');
            if (video) {
                video.srcObject = null;
                video.pause();
            }
            resetCameraUI();
        }

        async function startCamera() {
            try {
                const constraints = {
                    video: {
                        facingMode: isFrontCamera ? 'user' : 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: true
                };

                console.log('üì∑ Starting camera...');
                cameraStream = await navigator.mediaDevices.getUserMedia(constraints);

                const video = document.getElementById('camera-preview');
                video.srcObject = cameraStream;

                // Set video attributes
                video.setAttribute('autoplay', '');
                video.setAttribute('playsinline', '');
                video.setAttribute('muted', ''); // Mute to allow autoplay on mobile

                // Wait for video to be ready and play
                await new Promise((resolve, reject) => {
                    video.onloadedmetadata = async () => {
                        try {
                            await video.play();
                            console.log('‚úì Video playing');
                            resolve();
                        } catch (err) {
                            console.error('Video play error:', err);
                            reject(err);
                        }
                    };
                });

                // Show camera controls
                document.getElementById('camera-preview-container').style.display = 'block';
                document.getElementById('start-camera-btn').style.display = 'none';
                document.getElementById('switch-camera-btn').style.display = 'inline-block';
                document.getElementById('take-photo-btn').style.display = 'inline-block';
                document.getElementById('start-record-btn').style.display = 'inline-block';
                document.getElementById('close-camera-btn').style.display = 'inline-block';

                console.log('‚úì Camera started successfully');
            } catch (error) {
                console.error('‚ùå Camera error:', error);
                let errorMessage = 'Camera error: ';

                if (error.name === 'NotAllowedError') {
                    errorMessage += 'Permission denied. Please allow camera access.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage += 'No camera found on this device.';
                } else if (error.name === 'NotReadableError') {
                    errorMessage += 'Camera is already in use by another app.';
                } else {
                    errorMessage += error.message;
                }

                alert(errorMessage);
            }
        }

        function switchCamera() {
            isFrontCamera = !isFrontCamera;
            closeCamera();
            startCamera();
        }

        function takePhoto() {
            const video = document.getElementById('camera-preview');
            const canvas = document.getElementById('photo-canvas');

            // Check if video is playing
            if (video.readyState < 2) {
                alert('‚ö†Ô∏è Camera not ready yet. Please wait a moment.');
                return;
            }

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);

            canvas.toBlob((blob) => {
                if (!blob) {
                    alert('‚ùå Failed to capture photo. Please try again.');
                    return;
                }

                const now = new Date();
                const filename = `photo_${now.toISOString().replace(/[:.]/g,'-')}.jpg`;
                const preview = URL.createObjectURL(blob);

                // Add to gallery
                capturedMedia.push({
                    blob: blob,
                    filename: filename,
                    type: 'photo',
                    preview: preview
                });

                updateMediaGallery();
                showToast('Photo captured! Take more or submit report.', 'success', 2000);

                // Keep camera open for more photos
            }, 'image/jpeg', 0.92);
        }

        function startRecording() {
            recordedChunks = [];
            mediaRecorder = new MediaRecorder(cameraStream, { mimeType: 'video/webm; codecs=vp8' });

            mediaRecorder.ondataavailable = (e) => {
                if (e.data && e.data.size) recordedChunks.push(e.data);
            };

            mediaRecorder.onstop = () => {
                if (recordedChunks.length === 0) {
                    alert('‚ùå No video data recorded. Please try again.');
                    return;
                }

                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const now = new Date();
                const filename = `video_${now.toISOString().replace(/[:.]/g,'-')}.webm`;
                const preview = URL.createObjectURL(blob);

                // Add to gallery
                capturedMedia.push({
                    blob: blob,
                    filename: filename,
                    type: 'video',
                    preview: preview
                });

                updateMediaGallery();
                showToast('Video recorded! Capture more or submit report.', 'success', 2000);

                // Reset recording buttons
                document.getElementById('start-record-btn').style.display = 'inline-block';
                document.getElementById('stop-record-btn').style.display = 'none';
            };

            mediaRecorder.start();
            document.getElementById('start-record-btn').style.display = 'none';
            document.getElementById('stop-record-btn').style.display = 'inline-block';
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
        }

        // ===== QR SCANNER FOR TOOLS =====
        function showToolScanner() {
            document.getElementById('tool-scanner-modal').style.display = 'block';
            document.getElementById('scanner-status').innerHTML = 'Ready to scan QR code';
        }

        function closeToolScanner() {
            if (qrScanner) {
                qrScanner.stop();
                qrScanner = null;
            }
            document.getElementById('tool-scanner-modal').style.display = 'none';
            document.getElementById('scanner-container').style.display = 'none';
            document.getElementById('tool-action-container').style.display = 'none';
        }

        async function startToolScanner() {
            const video = document.getElementById('qr-video');
            const container = document.getElementById('scanner-container');

            try {
                container.style.display = 'block';
                document.getElementById('start-scanner-btn').style.display = 'none';
                document.getElementById('stop-scanner-btn').style.display = 'block';

                qrScanner = new QrScanner(
                    video,
                    result => handleToolQRScan(result.data),
                    { returnDetailedScanResult: true, highlightScanRegion: true }
                );

                await qrScanner.start();
                document.getElementById('scanner-status').innerHTML = 'üîç Scanning for QR codes...';
            } catch (error) {
                alert('Camera error: ' + error.message);
                console.error(error);
            }
        }

        function stopToolScanner() {
            if (qrScanner) {
                qrScanner.stop();
                qrScanner = null;
            }
            document.getElementById('scanner-container').style.display = 'none';
            document.getElementById('start-scanner-btn').style.display = 'block';
            document.getElementById('stop-scanner-btn').style.display = 'none';
        }

        function handleToolQRScan(scannedData) {
            let toolData;
            try {
                toolData = JSON.parse(scannedData);
            } catch {
                toolData = { id: scannedData };
            }

            const tool = hubState.tools?.find(t => t.id === toolData.id || t.serial === toolData.serial);

            if (!tool) {
                document.getElementById('scanner-status').innerHTML = '‚ùå Tool not found';
                return;
            }

            stopToolScanner();
            scannedToolId = tool.id;

            document.getElementById('tool-action-container').style.display = 'block';
            document.getElementById('scanned-tool-name').textContent = tool.name;
            document.getElementById('scanned-tool-info').textContent = `Serial: ${tool.serial}`;

            if (tool.status === 'available') {
                document.getElementById('checkout-btn').style.display = 'block';
                document.getElementById('checkin-btn').style.display = 'none';
                document.getElementById('scanner-status').innerHTML = '‚úÖ Tool available';
            } else if (tool.checkedOutTo === currentUser.id) {
                document.getElementById('checkout-btn').style.display = 'none';
                document.getElementById('checkin-btn').style.display = 'block';
                document.getElementById('scanner-status').innerHTML = 'üì• You have this tool';
            } else {
                document.getElementById('checkout-btn').style.display = 'none';
                document.getElementById('checkin-btn').style.display = 'none';
                document.getElementById('scanner-status').innerHTML = `‚ùå Checked out to ${tool.checkedOutBy}`;
            }
        }

        async function checkoutScannedTool() {
            const tool = hubState.tools.find(t => t.id === scannedToolId);
            if (!tool) return;

            tool.status = 'checked-out';
            tool.checkedOutTo = currentUser.id;
            tool.checkedOutBy = currentUser.name;
            tool.checkedOutAt = new Date().toISOString();

            logActivity('TOOL_CHECKOUT', `Checked out: ${tool.name} (${tool.serial})`);
            await saveHubState();

            alert(`‚úÖ ${tool.name} checked out!`);
            closeToolScanner();
        }

        async function checkinScannedTool() {
            const tool = hubState.tools.find(t => t.id === scannedToolId);
            if (!tool) return;

            tool.status = 'available';
            tool.checkedOutTo = null;
            tool.checkedOutBy = null;
            tool.checkedOutAt = null;

            logActivity('TOOL_CHECKIN', `Returned: ${tool.name} (${tool.serial})`);
            await saveHubState();

            alert(`‚úÖ ${tool.name} checked in!`);
            closeToolScanner();
        }

        function showToolsModal() {
            const modal = document.getElementById('tools-modal');
            const list = document.getElementById('available-tools-list');

            list.innerHTML = '';

            if (!hubState.tools || hubState.tools.length === 0) {
                list.innerHTML = '<div class="empty-state"><div>No tools available</div></div>';
                modal.style.display = 'block';
                return;
            }

            hubState.tools.forEach(tool => {
                const available = tool.status === 'available';
                const div = document.createElement('div');
                div.style.cssText = 'padding: 12px; margin-bottom: 8px; background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: 8px; display: flex; justify-content: space-between; align-items: center;';
                div.innerHTML = `
                    <div>
                        <div style="font-weight: 600;">${tool.name}</div>
                        <div style="font-size: 12px; color: var(--text-secondary);">${tool.serial}</div>
                    </div>
                    <button class="btn-sm ${available ? 'btn-start' : ''}" onclick="toggleTool('${tool.id}')" ${!available && tool.checkedOutTo !== currentUser.id ? 'disabled' : ''}>
                        ${available ? 'Sign Out' : (tool.checkedOutTo === currentUser.id ? 'Return' : 'In Use')}
                    </button>
                `;
                list.appendChild(div);
            });

            modal.style.display = 'block';
        }

        function closeToolsModal() {
            document.getElementById('tools-modal').style.display = 'none';
        }

        async function toggleTool(toolId) {
            const tool = hubState.tools.find(t => t.id === toolId);
            if (!tool) return;

            if (tool.status === 'available') {
                tool.status = 'checked-out';
                tool.checkedOutTo = currentUser.id;
                tool.checkedOutBy = currentUser.name;
                tool.checkedOutAt = new Date().toISOString();
                logActivity('TOOL_CHECKOUT', `Checked out: ${tool.name}`);
            } else if (tool.checkedOutTo === currentUser.id) {
                tool.status = 'available';
                tool.checkedOutTo = null;
                tool.checkedOutBy = null;
                tool.checkedOutAt = null;
                logActivity('TOOL_CHECKIN', `Returned: ${tool.name}`);
            }

            await saveHubState();
            showToolsModal(); // Refresh
        }

        async function requestClockOut() {
            // Check if there are incomplete tasks
            let hasIncompleteTasks = false;
            if (selectedProject && selectedProject.areas) {
                selectedProject.areas.forEach(area => {
                    if (area.tasks) {
                        const incompleteTasks = area.tasks.filter(t =>
                            t.status === 'inprogress' ||
                            (isTaskAssignedToMe(t) && !t.completed)
                        );
                        if (incompleteTasks.length > 0) {
                            hasIncompleteTasks = true;
                        }
                    }
                });
            }

            if (hasIncompleteTasks) {
                const confirm = window.confirm('You have incomplete tasks for today. Are you sure you want to clock out?');
                if (!confirm) return;
            }

            clockOut();
        }

        async function clockOut() {
            if (!hubState.timeEntries) hubState.timeEntries = [];

            hubState.timeEntries.push({
                id: Date.now().toString(),
                userId: currentUser.id,
                userName: currentUser.name,
                projectId: selectedProject.id,
                type: 'out',
                timestamp: new Date().toISOString()
            });

            logActivity('CLOCK_OUT', `Clocked out from ${selectedProject.name}`);

            await saveHubState();

            selectedProject = null;
            currentTask = null;
            clockedInTime = null;

            // Reset to initial screen
            document.getElementById('task-selection-screen').classList.add('hidden');
            document.getElementById('active-task-screen').classList.add('hidden');
            document.getElementById('clock-in-screen').classList.remove('hidden');
            document.getElementById('clock-out-fixed-btn').style.display = 'none';

            alert('Clocked out successfully!');
        }

        function logActivity(type, message, details = {}) {
            if (!hubState.activities) hubState.activities = [];

            hubState.activities.push({
                id: Date.now().toString(),
                type: type,
                userId: currentUser.id,
                userName: currentUser.name,
                projectId: selectedProject ? selectedProject.id : null,
                projectName: selectedProject ? selectedProject.name : null,
                message: message,
                details: details,
                timestamp: new Date().toISOString(),
                source: 'worker'
            });

            // Note: Parent functions will call saveHubState()
        }

        function logout() {
            if (clockedInTime) {
                alert('Please clock out before logging out.');
                return;
            }

            localStorage.removeItem('pm_hub_current_user');
            window.location.href = 'index.html';
        }

        // ===== OFFLINE MEDIA STORAGE =====
        function storeMediaForLaterUpload(blob, filename, task) {
            // Convert blob to base64 for localStorage
            const reader = new FileReader();
            reader.onloadend = function() {
                const base64data = reader.result;

                if (!hubState.syncQueue) hubState.syncQueue = [];

                hubState.syncQueue.push({
                    id: Date.now().toString(),
                    actionType: 'uploadMedia',
                    data: {
                        base64: base64data,
                        filename: filename,
                        projectId: selectedProject.id,
                        areaId: task ? task.areaId : null,
                        taskWbs: task ? task.wbs : null,
                        taskName: task ? task.name : null
                    },
                    timestamp: new Date().toISOString(),
                    retries: 0
                });

                saveHubState();
                console.log('Media queued for upload:', filename);
            };
            reader.readAsDataURL(blob);
        }

        async function processPendingUploads() {
            if (!navigator.onLine || !accessToken || !hubState.syncQueue) {
                return;
            }

            console.log('Processing pending uploads...');
            const mediaItems = hubState.syncQueue.filter(item => item.actionType === 'uploadMedia');

            for (const item of mediaItems) {
                try {
                    // Convert base64 back to blob
                    const response = await fetch(item.data.base64);
                    const blob = await response.blob();

                    // Find folder ID
                    const project = hubState.projects.find(p => p.id == item.data.projectId);
                    if (!project) continue;

                    let folderId = project.driveFolderId;

                    if (item.data.areaId && project.areas) {
                        const area = project.areas.find(a => a.id == item.data.areaId);
                        if (area && area.driveFolderId) {
                            folderId = area.driveFolderId;

                            if (item.data.taskWbs && area.tasks) {
                                const task = area.tasks.find(t => t.wbs == item.data.taskWbs);
                                if (task && task.driveFolderId) {
                                    folderId = task.driveFolderId;
                                }
                            }
                        }
                    }

                    // Upload to Drive
                    if (folderId) {
                        const uploadResult = await uploadToGoogleDrive(blob, item.data.filename, folderId);

                        if (uploadResult && uploadResult.id) {
                            console.log('Successfully uploaded:', item.data.filename);

                            // Remove from queue
                            hubState.syncQueue = hubState.syncQueue.filter(q => q.id !== item.id);
                            await saveHubState();
                        }
                    }
                } catch (error) {
                    console.error('Failed to upload:', item.data.filename, error);
                    item.retries = (item.retries || 0) + 1;

                    if (item.retries >= 3) {
                        console.error('Removing after 3 failed attempts:', item.data.filename);
                        hubState.syncQueue = hubState.syncQueue.filter(q => q.id !== item.id);
                    }
                    await saveHubState();
                }
            }

            if (mediaItems.length > 0 && hubState.syncQueue.filter(item => item.actionType === 'uploadMedia').length === 0) {
                showToast('All offline media uploaded successfully!', 'success');
                updatePendingUploads();
            }
        }

        // Listen for online/offline events
        window.addEventListener('online', async () => {
            console.log('Worker app: Connection restored');
            hubState.isOnline = true;
            updateSyncStatus('syncing');
            await saveHubState();

            // Show toast notification
            showToast('Back online - syncing data...', 'success');

            // Process pending uploads
            if (accessToken) {
                processPendingUploads();
            }
        });

        window.addEventListener('offline', async () => {
            console.log('Worker app: Connection lost');
            hubState.isOnline = false;
            updateSyncStatus('offline');
            localStorage.setItem('pmSystemState', JSON.stringify(hubState));

            // Show toast notification
            showToast('Offline - changes will be saved locally', 'warning');
        });

        // Initialize on load
        window.addEventListener('DOMContentLoaded', init);
    </script>

    <!-- Real-Time Sync & Notifications -->
    <script src="pm-hub-realtime.js"></script>
    <script>
        // Initialize real-time sync after page load
        window.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                if (currentUser && window.PMHubRealtimeSync) {
                    window.pmRealtime = new PMHubRealtimeSync({
                        appName: 'Worker',
                        currentUser: currentUser,
                        onStateUpdate: (newState, update) => {
                            console.log('üîÑ Worker: State update received', update);

                            // Update local state
                            hubState = newState;

                            // Add notification if there's activity info relevant to this worker
                            if (update.activity && update.syncedBy) {
                                // Filter notifications relevant to workers
                                const relevantTypes = [
                                    'TASK_ASSIGNED',
                                    'TASK_UPDATED',
                                    'TASK_CREATED',
                                    'TASK_PRIORITY_CHANGED',
                                    'TASK_MESSAGE',
                                    'AREA_CREATED',
                                    'MANAGER_COMMENT',
                                    'PROJECT_UPDATE',
                                    'CALENDAR_EVENT',
                                    'TOOL_AVAILABLE'
                                ];

                                // Check if this is a task assigned to current worker
                                const isTaskForWorker = update.activity.details?.assignee === currentUser.name ||
                                                       update.activity.details?.assignees?.includes(currentUser.name) ||
                                                       update.activity.details?.taskAssignee === currentUser.name;

                                // Show notification if it's a relevant type or assigned to this worker
                                if (relevantTypes.includes(update.activity.type) || isTaskForWorker) {
                                    addNotification(update.activity, update.syncedBy);
                                }
                            }

                            // CLOCK-IN SCREEN: Refresh project list (in case new projects added)
                            const clockInScreen = document.getElementById('clock-in-screen');
                            if (clockInScreen && !clockInScreen.classList.contains('hidden')) {
                                loadProjects(); // Refresh project dropdown
                                console.log('üîÑ Worker: Project list refreshed');
                            }

                            // TASK SELECTION SCREEN: Refresh task list
                            if (selectedProject) {
                                selectedProject = hubState.projects?.find(p => p.id == selectedProject.id);
                                const taskScreen = document.getElementById('task-selection-screen');
                                if (taskScreen && !taskScreen.classList.contains('hidden')) {
                                    // Refresh area dropdown (in case areas added/changed)
                                    loadAreas();

                                    // Refresh task list for current area
                                    const currentAreaId = document.getElementById('area-select')?.value;
                                    if (currentAreaId) {
                                        loadTasksForArea();
                                        console.log('üîÑ Worker: Task list refreshed');
                                    }
                                }
                            }

                            // ACTIVE TASK SCREEN: Update current task with latest data
                            if (currentTask) {
                                const project = hubState.projects?.find(p => p.id == currentTask.projectId);
                                if (project) {
                                    const area = project.areas?.find(a => a.id == currentTask.areaId);
                                    if (area) {
                                        const task = area.tasks?.find(t => t.wbs == currentTask.wbs);
                                        if (task) {
                                            // Update currentTask with full task data + context
                                            currentTask = {
                                                ...task, // Copy all task properties including conversation
                                                projectId: project.id,
                                                projectName: project.name,
                                                areaId: area.id,
                                                areaName: area.name
                                            };

                                            // If chat is open, refresh messages immediately
                                            const chatModal = document.getElementById('task-chat-modal');
                                            if (chatModal && chatModal.classList.contains('active')) {
                                                console.log('üí¨ Worker: Chat update detected, refreshing messages');
                                                renderChatMessages();
                                                markChatMessagesRead();

                                                // Update message count for polling
                                                lastMessageCount = task.conversation?.messages?.length || 0;
                                            }

                                            // Update chat badge
                                            updateChatBadge();

                                            console.log('‚úÖ Worker: Current task updated');
                                        }
                                    }
                                }
                            }

                            console.log('‚úÖ Worker: All views refreshed');
                        }
                    });
                    console.log('‚úì Worker: Real-time sync initialized');
                }
            }, 1000); // Wait for init() to complete
        });
    </script>
</body>
</html>
